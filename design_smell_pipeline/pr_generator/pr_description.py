"""
PR Description Generator - Create detailed Pull Request descriptions

This module handles:
1. Formatting detected smells
2. Documenting applied refactoring techniques
3. Showing before/after metrics
4. Creating Markdown-formatted descriptions
"""

import logging
from datetime import datetime
from typing import Dict, List, Optional
from dataclasses import dataclass

logger = logging.getLogger(__name__)


@dataclass
class RefactoringResult:
    """Result of a single file refactoring"""
    file_path: str
    class_name: str
    smells_fixed: List[Dict]
    original_metrics: Dict
    new_metrics: Dict
    diff_summary: str = ""


class PRDescriptionGenerator:
    """
    Generates detailed and well-formatted Pull Request descriptions.
    
    Includes:
    - Summary of detected smells
    - Applied refactoring techniques
    - Before/After metrics comparison
    - Validation results
    """
    
    # Emoji mappings for visual appeal
    SMELL_EMOJIS = {
        "God Class": "ðŸ›ï¸",
        "Long Method": "ðŸ“œ",
        "Feature Envy": "ðŸ‘€",
        "Data Class": "ðŸ“¦",
        "Complex Method": "ðŸŒ€",
        "Long Parameter List": "ðŸ“‹",
        "Duplicate Abstraction": "ðŸ‘¯",
    }
    
    def __init__(self, config: Dict):
        """
        Initialize the generator.
        
        Args:
            config: Pipeline configuration
        """
        self.config = config
        
    def generate_full_description(
        self,
        refactoring_results: List[RefactoringResult],
        validation_passed: bool = True,
        execution_time: Optional[float] = None
    ) -> str:
        """
        Generate a complete PR description.
        
        Args:
            refactoring_results: List of refactoring results
            validation_passed: Whether all validations passed
            execution_time: Pipeline execution time in seconds
            
        Returns:
            Markdown-formatted PR description
        """
        sections = [
            self._generate_header(),
            self._generate_summary(refactoring_results, execution_time),
            self._generate_smell_details(refactoring_results),
            self._generate_refactoring_details(refactoring_results),
            self._generate_metrics_comparison(refactoring_results),
            self._generate_validation_results(validation_passed),
            self._generate_files_changed(refactoring_results),
            self._generate_footer()
        ]
        
        return "\n\n".join(sections)
        
    def _generate_header(self) -> str:
        """Generate the PR header."""
        return """## ðŸ”§ Automated Design Smell Refactoring

This PR was automatically generated by the **Design Smell Detection & Refactoring Pipeline**.

The pipeline analyzed the codebase for design smells using **DesigniteJava** and **TypeMetrics**, 
then applied LLM-powered refactoring to improve code quality."""
        
    def _generate_summary(
        self, 
        results: List[RefactoringResult],
        execution_time: Optional[float]
    ) -> str:
        """Generate the summary section."""
        total_smells = sum(len(r.smells_fixed) for r in results)
        date = datetime.now().strftime('%Y-%m-%d %H:%M')
        
        lines = [
            "### ðŸ“Š Summary",
            "",
            f"| Metric | Value |",
            f"|--------|-------|",
            f"| Files Refactored | {len(results)} |",
            f"| Smells Fixed | {total_smells} |",
            f"| Generated | {date} |",
        ]
        
        if execution_time:
            minutes = int(execution_time // 60)
            seconds = int(execution_time % 60)
            lines.append(f"| Execution Time | {minutes}m {seconds}s |")
            
        return "\n".join(lines)
        
    def _generate_smell_details(self, results: List[RefactoringResult]) -> str:
        """Generate detailed smell information."""
        lines = [
            "### ðŸ” Detected Design Smells",
            "",
            "| File | Smell Type | Severity | Details |",
            "|------|-----------|----------|---------|",
        ]
        
        for result in results:
            for smell in result.smells_fixed:
                emoji = self.SMELL_EMOJIS.get(smell.get('type', ''), 'âš ï¸')
                lines.append(
                    f"| `{result.class_name}` | {emoji} {smell.get('type', 'Unknown')} | "
                    f"{smell.get('severity', 'medium')} | {smell.get('cause', '')[:50]}... |"
                )
                
        return "\n".join(lines)
        
    def _generate_refactoring_details(self, results: List[RefactoringResult]) -> str:
        """Generate details about applied refactoring techniques."""
        lines = [
            "### âœ¨ Applied Refactoring Techniques",
            "",
        ]
        
        for result in results:
            lines.append(f"#### `{result.class_name}`")
            lines.append("")
            
            for smell in result.smells_fixed:
                smell_type = smell.get('type', 'Unknown')
                technique = self._get_refactoring_technique(smell_type)
                lines.append(f"- **{smell_type}**: {technique}")
                
            lines.append("")
            
        return "\n".join(lines)
        
    def _get_refactoring_technique(self, smell_type: str) -> str:
        """Get the refactoring technique description for a smell type."""
        techniques = {
            "God Class": "Extracted responsibilities into focused classes using Single Responsibility Principle",
            "Long Method": "Applied Extract Method to create smaller, well-named methods",
            "Feature Envy": "Moved method to the class it's most interested in",
            "Data Class": "Added behavior methods to encapsulate data operations",
            "Complex Method": "Simplified using guard clauses and method extraction",
            "Long Parameter List": "Introduced Parameter Object to group related parameters",
            "Duplicate Abstraction": "Extracted common behavior into shared base class",
        }
        
        return techniques.get(smell_type, "Applied appropriate refactoring patterns")
        
    def _generate_metrics_comparison(self, results: List[RefactoringResult]) -> str:
        """Generate before/after metrics comparison."""
        lines = [
            "### ðŸ“ˆ Metrics Comparison",
            "",
            "| File | Metric | Before | After | Change |",
            "|------|--------|--------|-------|--------|",
        ]
        
        for result in results:
            old = result.original_metrics
            new = result.new_metrics
            
            # LOC comparison
            old_loc = old.get('loc', 0)
            new_loc = new.get('loc', 0)
            loc_change = new_loc - old_loc
            loc_indicator = "ðŸ”»" if loc_change < 0 else "ðŸ”º" if loc_change > 0 else "âž–"
            lines.append(
                f"| `{result.class_name}` | LOC | {old_loc} | {new_loc} | {loc_indicator} {loc_change:+d} |"
            )
            
            # Complexity comparison
            old_cc = old.get('cyclomatic_complexity', 0)
            new_cc = new.get('cyclomatic_complexity', 0)
            cc_change = new_cc - old_cc
            cc_indicator = "ðŸ”»" if cc_change < 0 else "ðŸ”º" if cc_change > 0 else "âž–"
            lines.append(
                f"| | Cyclomatic Complexity | {old_cc} | {new_cc} | {cc_indicator} {cc_change:+d} |"
            )
            
            # Methods comparison
            old_methods = old.get('methods_count', 0)
            new_methods = new.get('methods_count', 0)
            methods_change = new_methods - old_methods
            lines.append(
                f"| | Methods | {old_methods} | {new_methods} | {methods_change:+d} |"
            )
            
        return "\n".join(lines)
        
    def _generate_validation_results(self, passed: bool) -> str:
        """Generate validation results section."""
        status = "âœ…" if passed else "âŒ"
        
        lines = [
            "### ðŸ§ª Validation Results",
            "",
            f"| Check | Status |",
            f"|-------|--------|",
            f"| Syntax Validation | {status} Passed |",
            f"| Compilation | {status} Passed |",
            f"| Unit Tests | {status} Passed |",
        ]
        
        if not passed:
            lines.extend([
                "",
                "> âš ï¸ **Note**: Some validations may have failed. Please review the changes carefully.",
            ])
            
        return "\n".join(lines)
        
    def _generate_files_changed(self, results: List[RefactoringResult]) -> str:
        """Generate list of files changed."""
        lines = [
            "### ðŸ“ Files Changed",
            "",
        ]
        
        for result in results:
            lines.append(f"- `{result.file_path}`")
            
        return "\n".join(lines)
        
    def _generate_footer(self) -> str:
        """Generate the PR footer."""
        return """---

### ðŸ¤– About This PR

This PR was generated by the [Design Smell Detection Pipeline](./design_smell_pipeline/README.md).

**Reviewers**: Please verify that:
- [ ] The refactored code maintains the original functionality
- [ ] The code follows project coding standards
- [ ] All tests pass after the changes
- [ ] The refactoring improves code readability

<details>
<summary>Pipeline Configuration</summary>

- **Detection Tool**: DesigniteJava
- **Metrics Tool**: TypeMetrics
- **LLM Provider**: Configured in pipeline
- **Schedule**: Daily at 2:00 AM

</details>"""
        
    def generate_compact_description(
        self,
        refactoring_results: List[RefactoringResult]
    ) -> str:
        """
        Generate a compact PR description for smaller changes.
        
        Args:
            refactoring_results: List of refactoring results
            
        Returns:
            Compact Markdown description
        """
        total_smells = sum(len(r.smells_fixed) for r in results)
        files = [r.class_name for r in refactoring_results]
        
        smell_types = set()
        for result in refactoring_results:
            for smell in result.smells_fixed:
                smell_types.add(smell.get('type', 'Unknown'))
                
        return f"""## ðŸ”§ Design Smell Refactoring

**Files**: {', '.join(f'`{f}`' for f in files)}

**Smells Fixed** ({total_smells}): {', '.join(smell_types)}

All validations âœ… passed. Please review the changes and merge if appropriate."""


if __name__ == "__main__":
    # Test description generation
    results = [
        RefactoringResult(
            file_path="org/apache/roller/weblogger/UserService.java",
            class_name="UserService",
            smells_fixed=[
                {'type': 'God Class', 'cause': 'Too many responsibilities', 'severity': 'high'},
                {'type': 'Long Method', 'cause': 'Method exceeds 100 lines', 'severity': 'medium'}
            ],
            original_metrics={'loc': 500, 'cyclomatic_complexity': 45, 'methods_count': 25},
            new_metrics={'loc': 350, 'cyclomatic_complexity': 28, 'methods_count': 30}
        )
    ]
    
    generator = PRDescriptionGenerator({})
    description = generator.generate_full_description(results)
    print(description)
